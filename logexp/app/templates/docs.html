{% extends "base.html" %}
{% block title %}Documentation - LogExp{% endblock %}
{% block content %}
  <h2>Documentation</h2>
  <p>Welcome to the LogExp documentation. Here you‚Äôll find details on setup, usage, and troubleshooting.</p>

  <h3>Quickstart</h3>
  <ul>
    <li>Install dependencies: <code>pip install -r requirements.txt</code></li>
    <li>Configure environment: <code>export DATABASE_URL=...</code></li>
    <li>Initialize DB: <code>flask db upgrade</code></li>
    <li>Run app: <code>flask run</code></li>
  </ul>

  <h3>Endpoints</h3>
  <ul>
    <li><code>/readings</code> ‚Üí Web UI page showing readings table and chart</li>
    <li><code>/api/readings.json</code> ‚Üí JSON of stored readings</li>
    <li><code>/api/poller/status</code> ‚Üí Poller health check</li>
    <li><code>/api/poller/start</code> ‚Üí Start the poller</li>
    <li><code>/api/poller/stop</code> ‚Üí Stop the poller</li>
    <li><code>/api/geiger/test</code> ‚Üí Diagnostic endpoint</li>
  </ul>

  <h3>Poller Lifecycle</h3>
  <p>The Geiger poller now starts automatically when the app launches and continues running until explicitly stopped. 
     Use the API endpoints or CLI commands (<code>flask geiger-stop</code>, <code>flask geiger-start</code>) to control it.</p>

  <h3>Timezone Handling</h3>
  <p>Readings are stored in UTC in the database. The Web UI renders timestamps in 
     <code>America/Chicago</code> timezone by default, using a 24‚Äëhour clock format.</p>

  <h3>Troubleshooting</h3>
  <p>See <code>README.md</code> for detailed troubleshooting steps including Alembic migrations and poller lifecycle management.</p>

  <h3>FAQ</h3>
  <dl>
    <dt>‚ùì Why do I see ‚Äúcannot join current thread‚Äù when stopping the poller?</dt>
    <dd>This happens if the teardown is called inside the poller thread. It‚Äôs safe to ignore; LogExp skips joining in that case.</dd>

    <dt>‚ùì Alembic migration errors: ‚Äústale revision‚Äù or ‚Äúno such table alembic_version‚Äù</dt>
    <dd>Clear the <code>alembic_version</code> table and re‚Äëinit migrations. See README for reset commands.</dd>

    <dt>‚ùì Timezone mismatch in readings</dt>
    <dd>Ensure <code>LOCAL_TIMEZONE</code> is set correctly in your environment. Defaults to <code>America/Chicago</code> with 24‚Äëhour clock display.</dd>

    <dt>‚ùì Why does the index page show a 500 error?</dt>
    <dd>Check that all blueprints are registered and templates reference the correct endpoint namespace (e.g. <code>routes_ui.index</code>).</dd>
  </dl>

  <h3>Hardware: MightyOhm Geiger Counter</h3>
  <p>LogExp integrates with the <a href="https://mightyohm.com/blog/products/geiger-counter/" target="_blank">MightyOhm Geiger Counter</a>, 
     a DIY radiation detector kit designed for hobbyists and researchers.</p>
  <ul>
    <li>USB‚Äëserial interface for easy data ingestion</li>
    <li>Outputs counts per second/minute and microsieverts/hour</li>
    <li>Open hardware design with accessible documentation</li>
    <li>Ideal for logging radiation levels in real‚Äëtime with LogExp</li>
  </ul>
  <p>For full specifications and assembly details, see the official product page: 
    <a href="https://mightyohm.com/blog/products/geiger-counter/" target="_blank">MightyOhm Geiger Counter</a>.
  </p>

  <h3>System Diagram</h3>
  <pre>
  [MightyOhm Geiger Counter]
              ‚îÇ USB-Serial
              ‚ñº
        [LogExp Poller Service]
              ‚îÇ
              ‚ñº
        [Postgres Database]
              ‚îÇ
              ‚ñº
        [Flask API Endpoints]
              ‚îÇ
              ‚ñº
        [Web UI / Clients]
  </pre>

  <h3>Sample Reading Output</h3>
  <p>Example JSON payload returned by <code>/api/readings.json</code>:</p>
  <pre>
  [
    {
      "id": 1,
      "timestamp": "2025-12-09T17:30:00Z",
      "counts_per_second": 0.7,
      "counts_per_minute": 42,
      "microsieverts_per_hour": 0.12,
      "mode": "normal"
    },
    {
      "id": 2,
      "timestamp": "2025-12-09T17:31:00Z",
      "counts_per_second": 0.8,
      "counts_per_minute": 47,
      "microsieverts_per_hour": 0.14,
      "mode": "normal"
    }
  ]
  </pre>
<section id="troubleshooting">
  <h2>üõ† Troubleshooting Timezone Issues</h2>

  <h3>Symptom</h3>
  <ul>
    <li>JSON shows timestamps like <code>"2025-12-12T10:53:42Z"</code>.</li>
    <li>Frontend chart displays values six hours behind (e.g. <code>04:53 CST</code> instead of <code>10:53 CST</code>).</li>
  </ul>

  <h3>Root Cause</h3>
  <p>
    The backend was stamping <strong>local Central time</strong> and then labeling it as UTC (<code>Z</code>).
    This happened because <code>datetime.now(timezone.utc)</code> was used while the system clock was set to Central.
    That call does not convert local time into UTC ‚Äî it simply tags the local wall‚Äëclock with a UTC tzinfo.
  </p>

  <h3>Fix</h3>
  <ul>
    <li>Use <code>datetime.now().astimezone(timezone.utc)</code> everywhere a timestamp is created.</li>
    <li>Ensure the model column is defined with <code>db.DateTime(timezone=True)</code> so tzinfo is preserved.</li>
    <li>JSON serialization should always emit UTC with <code>Z</code>.</li>
  </ul>

  <h3>Verification</h3>
  <p>
    At <strong>10:30 CST</strong>:
  </p>
  <ul>
    <li>Backend stores <code>2025‚Äë12‚Äë12 16:30:00+00:00</code>.</li>
    <li>API emits <code>"2025-12-12T16:30:00Z"</code>.</li>
    <li>Browser parses UTC ‚Üí converts to Central ‚Üí shows <code>10:30 CST</code>.</li>
  </ul>

  <h3>Regression Test</h3>
  <pre><code class="language-python">
def test_timestamp_serialization_is_utc():
    local = datetime(2025, 12, 12, 10, 30).astimezone()  # 10:30 CST
    reading = LogExpReading(timestamp=local.astimezone(timezone.utc), ...)
    data = reading.to_dict()
    assert data["timestamp"].endswith("16:30:00Z")
  </code></pre>
</section>

<section id="faq-timezone">
  <h2>‚ùì FAQ: Why do my charts show times six hours off?</h2>

  <h3>Symptom</h3>
  <ul>
    <li>JSON responses show timestamps like <code>"2025-12-12T10:53:42Z"</code>.</li>
    <li>Charts display values six hours behind the expected wall‚Äëclock (e.g. <code>04:53 CST</code> instead of <code>10:53 CST</code>).</li>
  </ul>

  <h3>Cause</h3>
  <p>
    The backend was stamping the system‚Äôs <strong>local Central time</strong> and then labeling it as UTC (<code>Z</code>).
    This happened because <code>datetime.now(timezone.utc)</code> was used while the server clock was set to Central.
    That call does not convert local time into UTC ‚Äî it simply tags the local wall‚Äëclock with a UTC tzinfo.
  </p>

  <h3>Fix</h3>
  <ul>
    <li>Always use <code>datetime.now().astimezone(timezone.utc)</code> when creating timestamps.</li>
    <li>Ensure your model column is defined with <code>db.DateTime(timezone=True)</code> so tzinfo is preserved.</li>
    <li>JSON serialization should always emit UTC with <code>Z</code>.</li>
  </ul>

  <h3>Verification</h3>
  <p>
    At <strong>10:30 CST</strong>:
  </p>
  <ul>
    <li>Backend stores <code>2025‚Äë12‚Äë12 16:30:00+00:00</code>.</li>
    <li>API emits <code>"2025-12-12T16:30:00Z"</code>.</li>
    <li>Browser parses UTC ‚Üí converts to Central ‚Üí shows <code>10:30 CST</code>.</li>
  </ul>

  <h3>Correct Poller Code</h3>
  <pre><code class="language-python">
reading = LogExpReading(
    timestamp=datetime.now().astimezone(timezone.utc),  # convert local ‚Üí UTC
    counts_per_second=parsed["counts_per_second"],
    counts_per_minute=parsed["counts_per_minute"],
    microsieverts_per_hour=parsed["microsieverts_per_hour"],
    mode=parsed["mode"]
)
  </code></pre>
</section>


{% endblock %}
